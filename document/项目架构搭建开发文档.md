# AI学习助手 - React Native 项目架构搭建开发文档

> **文档版本**: V1.0  
> **创建日期**: 2024年12月  
> **作者**: 资深React Native架构工程师  
> **项目代号**: AI-Learning-Assistant-Mobile

---

## 目录

1. [项目概览](#1-项目概览)
2. [技术选型分析](#2-技术选型分析)
3. [整体架构设计](#3-整体架构设计)
4. [项目目录结构](#4-项目目录结构)
5. [核心模块设计](#5-核心模块设计)
6. [数据层架构](#6-数据层架构)
7. [UI层架构](#7-ui层架构)
8. [路由与导航](#8-路由与导航)
9. [状态管理方案](#9-状态管理方案)
10. [网络请求架构](#10-网络请求架构)
11. [本地存储方案](#11-本地存储方案)
12. [AI集成方案](#12-ai集成方案)
13. [性能优化策略](#13-性能优化策略)
14. [安全方案](#14-安全方案)
15. [开发环境配置](#15-开发环境配置)
16. [项目初始化步骤](#16-项目初始化步骤)
17. [开发规范](#17-开发规范)
18. [测试策略](#18-测试策略)
19. [CI/CD流程](#19-cicd流程)
20. [迭代开发计划](#20-迭代开发计划)

---

## 1. 项目概览

### 1.1 项目背景

基于产品需求文档,我们需要构建一个**AI驱动的全场景学习平台移动端应用**,核心功能包括:

- **语言学习模块**: 词汇、语法、听力、口语、阅读写作
- **记忆强化系统**: 基于间隔重复算法的智能复习
- **学习规划模块**: AI辅助的学习计划生成与追踪
- **笔记系统**: 支持Markdown的智能笔记管理
- **AI助手**: 24小时在线答疑与个性化辅导
- **数据中心**: 学习统计与可视化分析

### 1.2 技术挑战分析

#### 核心技术挑战

1. **离线优先架构**
   - 学习内容需要支持离线使用
   - 复习数据本地计算,网络恢复后同步
   - 保证离线状态下的完整功能体验

2. **复杂的算法实现**
   - SM-2间隔重复算法需要精确计算
   - 实时更新复习队列
   - 学习数据的统计分析

3. **AI服务集成**
   - API调用的性能优化
   - 响应流式处理
   - 错误重试与降级方案

4. **跨平台一致性**
   - iOS/Android UI一致性
   - 原生能力的跨平台封装
   - 性能差异的平衡

5. **数据同步机制**
   - 多设备数据同步
   - 冲突解决策略
   - 增量更新机制

### 1.3 架构设计目标

#### 可扩展性
- 模块化设计,易于添加新功能
- 插件化架构,支持功能动态加载
- 微服务化的后端对接能力

#### 可维护性
- 清晰的代码组织结构
- 完善的类型系统(TypeScript)
- 统一的编码规范

#### 高性能
- 首屏加载时间 < 2秒
- 页面切换流畅度 60fps
- 内存占用优化 < 150MB

#### 稳定性
- 崩溃率 < 0.1%
- API调用成功率 > 99%
- 离线功能可用率 100%

---

## 2. 技术选型分析

### 2.1 核心技术栈

#### React Native 版本选择

```
React Native: 0.73.x (最新稳定版)
理由:
✅ 性能优化(新架构支持)
✅ TypeScript内建支持
✅ 更好的调试工具
✅ 社区支持活跃
```

#### 开发语言

```
TypeScript 5.x
理由:
✅ 类型安全,减少运行时错误
✅ 更好的IDE支持与代码提示
✅ 团队协作友好
✅ 便于后期维护
```

### 2.2 状态管理方案

#### Redux Toolkit + RTK Query

```typescript
选择理由:
✅ Redux Toolkit简化了Redux样板代码
✅ RTK Query提供强大的数据获取和缓存
✅ 与TypeScript深度集成
✅ 中间件生态丰富(redux-persist)
✅ 团队成员熟悉度高

核心优势:
- 集中式状态管理,便于调试
- 时间旅行调试
- 强大的中间件支持
- 自动缓存与更新
```

**备选方案对比**:

| 方案 | 优势 | 劣势 | 选择理由 |
|------|------|------|---------|
| **Redux Toolkit** | 成熟稳定、生态丰富、调试工具强大 | 学习曲线较陡 | ✅ 适合复杂应用 |
| Zustand | 轻量、简单 | 大型应用可能复杂 | ❌ 功能不够强大 |
| MobX | 响应式、简洁 | 调试困难、不够透明 | ❌ 不适合团队 |
| Recoil | Facebook官方、现代化 | 生态不够成熟 | ❌ 风险较高 |

### 2.3 导航方案

#### React Navigation 6.x

```typescript
选择理由:
✅ 官方推荐的导航库
✅ 完全用JavaScript实现,跨平台一致
✅ 深度链接支持
✅ 类型安全(TypeScript)
✅ 可定制性强

核心导航器:
- Stack Navigator: 页面堆栈导航
- Bottom Tab Navigator: 底部Tab导航
- Drawer Navigator: 侧边栏导航(未来扩展)
```

**备选方案对比**:

| 方案 | 优势 | 劣势 | 选择 |
|------|------|------|------|
| **React Navigation** | 社区首选、文档完善 | 性能稍逊原生 | ✅ |
| React Native Navigation | 原生性能好 | 配置复杂、升级困难 | ❌ |

### 2.4 UI组件库

#### 自定义组件 + React Native Paper

```typescript
策略:
✅ 核心组件自定义开发(符合设计系统)
✅ 通用组件使用React Native Paper
✅ 图标使用react-native-vector-icons

选择理由:
- 设计系统独特,需要自定义
- Paper提供Material Design基础
- 便于主题切换(浅色/深色模式)
```

### 2.5 网络请求

#### Axios + RTK Query

```typescript
组合使用:
✅ Axios处理HTTP请求
✅ RTK Query处理数据缓存和状态
✅ 拦截器统一处理认证、错误

优势:
- 请求/响应拦截
- 自动重试
- 取消请求
- 缓存策略
```

### 2.6 本地存储

#### SQLite + AsyncStorage + MMKV

```typescript
分层存储策略:

1. MMKV (react-native-mmkv)
   - 用途: 高频读写的小数据
   - 场景: 用户设置、认证Token、临时缓存
   - 性能: 30x faster than AsyncStorage
   
2. SQLite (react-native-sqlite-storage)
   - 用途: 结构化数据存储
   - 场景: 学习卡片、笔记、复习记录
   - 优势: SQL查询、事务支持、大数据量
   
3. AsyncStorage
   - 用途: Redux持久化(redux-persist)
   - 场景: 全局状态持久化
   - 优势: 简单易用
```

### 2.7 AI服务集成

#### OpenAI API (初期) + 灵活多模型支持

```typescript
方案:
✅ 初期使用OpenAI GPT-4 API
✅ 抽象层设计,支持切换模型
✅ 流式响应处理
✅ 本地缓存常见问题答案

架构:
- AIService抽象接口
- OpenAIAdapter实现类
- 未来可扩展: ClaudeAdapter, LocalModelAdapter
```

### 2.8 图表与数据可视化

#### Victory Native + react-native-svg

```typescript
选择理由:
✅ Victory Native专为React Native设计
✅ 基于react-native-svg,性能好
✅ 支持动画
✅ 可定制性强

备选: react-native-chart-kit (简单场景)
```

### 2.9 音频处理

#### react-native-sound + react-native-voice

```typescript
音频播放: react-native-sound
- 单词发音播放
- 听力材料播放
- 支持变速

语音识别: react-native-voice
- 口语练习录音
- 语音输入转文字
```

### 2.10 其他关键依赖

```json
{
  "核心依赖": {
    "@react-navigation/native": "^6.1.x",
    "@react-navigation/stack": "^6.3.x",
    "@react-navigation/bottom-tabs": "^6.5.x",
    "@reduxjs/toolkit": "^2.0.x",
    "react-redux": "^9.0.x",
    "redux-persist": "^6.0.x"
  },
  "UI相关": {
    "react-native-paper": "^5.11.x",
    "react-native-vector-icons": "^10.0.x",
    "react-native-svg": "^14.0.x",
    "react-native-linear-gradient": "^2.8.x",
    "react-native-reanimated": "^3.6.x"
  },
  "数据存储": {
    "react-native-mmkv": "^2.11.x",
    "react-native-sqlite-storage": "^6.0.x",
    "@react-native-async-storage/async-storage": "^1.21.x"
  },
  "网络请求": {
    "axios": "^1.6.x",
    "@tanstack/react-query": "备选方案"
  },
  "工具库": {
    "date-fns": "^3.0.x",
    "lodash": "^4.17.x",
    "react-hook-form": "^7.49.x",
    "yup": "^1.3.x"
  },
  "开发工具": {
    "@types/react": "^18.2.x",
    "@types/react-native": "^0.73.x",
    "eslint": "^8.56.x",
    "prettier": "^3.1.x",
    "@typescript-eslint/parser": "^6.x.x"
  }
}
```

### 2.11 技术选型总结

```typescript
核心技术栈架构图:

┌─────────────────────────────────────┐
│         React Native 0.73.x         │
│         (TypeScript 5.x)            │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│  UI层: React Navigation + Custom UI │
│  状态: Redux Toolkit + RTK Query    │
│  存储: SQLite + MMKV + AsyncStorage │
│  网络: Axios + Interceptors         │
│  AI: OpenAI API (可扩展)            │
└─────────────────────────────────────┘
```

---

## 3. 整体架构设计

### 3.1 分层架构

采用经典的**三层架构**设计,保证职责分离和可维护性:

```
┌───────────────────────────────────────────┐
│           Presentation Layer              │
│         (UI Components & Screens)         │
│                                           │
│  ┌────────┐  ┌────────┐  ┌─────────┐    │
│  │ Screens│  │Componet│  │ Hooks   │    │
│  └────────┘  └────────┘  └─────────┘    │
└───────────────────────────────────────────┘
              ↓
┌───────────────────────────────────────────┐
│            Business Logic Layer           │
│       (State Management & Services)       │
│                                           │
│  ┌────────┐  ┌────────┐  ┌─────────┐    │
│  │ Redux  │  │Services│  │ Utils   │    │
│  │ Store  │  │ (AI等) │  │ (算法)  │    │
│  └────────┘  └────────┘  └─────────┘    │
└───────────────────────────────────────────┘
              ↓
┌───────────────────────────────────────────┐
│              Data Layer                   │
│        (API & Local Storage)              │
│                                           │
│  ┌────────┐  ┌────────┐  ┌─────────┐    │
│  │ API    │  │ SQLite │  │  MMKV   │    │
│  │ Client │  │Database│  │ Storage │    │
│  └────────┘  └────────┘  └─────────┘    │
└───────────────────────────────────────────┘
```

### 3.2 核心模块划分

基于产品需求,将应用划分为以下核心模块:

```typescript
应用模块结构:

AI学习助手
│
├── 1. 认证模块 (Auth)
│   ├── 登录/注册
│   ├── 第三方登录(微信、Apple)
│   └── Token管理
│
├── 2. 学习中心模块 (Learning)
│   ├── 语言学习
│   │   ├── 词汇学习
│   │   ├── 语法练习
│   │   ├── 听力训练
│   │   ├── 口语练习
│   │   └── 阅读写作
│   ├── 编程学习(未来)
│   └── 自定义学习
│
├── 3. 记忆强化模块 (Memory)
│   ├── 卡片管理
│   ├── 复习队列
│   ├── SM-2算法引擎
│   └── 复习统计
│
├── 4. 学习规划模块 (Planning)
│   ├── 目标管理
│   ├── 计划生成(AI辅助)
│   ├── 任务调度
│   └── 进度追踪
│
├── 5. 笔记模块 (Notes)
│   ├── Markdown编辑器
│   ├── 笔记组织(文件夹/标签)
│   ├── 全文搜索
│   └── 笔记同步
│
├── 6. AI助手模块 (AI)
│   ├── 智能答疑
│   ├── 对话练习
│   ├── 作文批改
│   └── 学习推荐
│
├── 7. 数据统计模块 (Analytics)
│   ├── 学习报告
│   ├── 数据可视化
│   └── 学习洞察
│
├── 8. 个人中心模块 (Profile)
│   ├── 用户信息
│   ├── 设置管理
│   ├── 成就系统
│   └── 会员中心
│
└── 9. 通用模块 (Common)
    ├── 网络请求
    ├── 本地存储
    ├── 工具函数
    └── 常量定义
```

### 3.3 数据流架构

```typescript
数据流向设计(单向数据流):

User Action
    ↓
UI Component
    ↓
dispatch(action)
    ↓
Redux Middleware (Thunk/Saga)
    ↓
API Service / Local Database
    ↓
Redux Reducer
    ↓
Update Store
    ↓
React Re-render
    ↓
UI Update
```

### 3.4 离线优先架构

```typescript
离线优先设计原则:

┌─────────────────────────────────────┐
│         User Interface              │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│      Local Database (SQLite)        │
│      - 学习内容本地缓存              │
│      - 复习数据本地计算              │
│      - 离线队列管理                  │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│      Sync Manager                   │
│      - 监测网络状态                  │
│      - 增量同步                      │
│      - 冲突解决                      │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│      Remote Server                  │
└─────────────────────────────────────┘

同步策略:
1. 写入操作先写本地数据库
2. 加入同步队列
3. 网络可用时批量同步
4. 服务端返回确认后更新本地状态
```

---

## 4. 项目目录结构

### 4.1 完整目录结构

```
ai-learning-assistant/
├── __tests__/                    # 测试文件
│   ├── components/              # 组件测试
│   ├── screens/                 # 页面测试
│   ├── services/                # 服务测试
│   └── utils/                   # 工具函数测试
│
├── android/                      # Android原生代码
├── ios/                          # iOS原生代码
│
├── src/                          # 源代码目录
│   │
│   ├── api/                      # API接口定义
│   │   ├── auth.api.ts          # 认证API
│   │   ├── learning.api.ts      # 学习内容API
│   │   ├── memory.api.ts        # 复习系统API
│   │   ├── planning.api.ts      # 学习规划API
│   │   ├── notes.api.ts         # 笔记API
│   │   ├── ai.api.ts            # AI服务API
│   │   ├── analytics.api.ts     # 数据统计API
│   │   └── index.ts             # API导出
│   │
│   ├── assets/                   # 静态资源
│   │   ├── fonts/               # 字体文件
│   │   ├── icons/               # 图标资源
│   │   ├── images/              # 图片资源
│   │   └── animations/          # Lottie动画
│   │
│   ├── components/               # 公共组件
│   │   ├── common/              # 通用组件
│   │   │   ├── Button/          # 按钮组件
│   │   │   │   ├── index.tsx
│   │   │   │   └── styles.ts
│   │   │   ├── Card/            # 卡片组件
│   │   │   ├── Input/           # 输入框组件
│   │   │   ├── Loading/         # 加载组件
│   │   │   ├── Modal/           # 模态框组件
│   │   │   ├── ProgressBar/     # 进度条组件
│   │   │   └── index.ts
│   │   │
│   │   ├── learning/            # 学习相关组件
│   │   │   ├── VocabularyCard/  # 单词卡片
│   │   │   ├── AudioPlayer/     # 音频播放器
│   │   │   ├── ExerciseItem/    # 练习题组件
│   │   │   └── index.ts
│   │   │
│   │   ├── memory/              # 记忆相关组件
│   │   │   ├── FlashCard/       # 记忆卡片
│   │   │   ├── ReviewQueue/     # 复习队列
│   │   │   ├── RatingButtons/   # 评分按钮
│   │   │   └── index.ts
│   │   │
│   │   ├── charts/              # 图表组件
│   │   │   ├── LineChart/       # 折线图
│   │   │   ├── PieChart/        # 饼图
│   │   │   ├── HeatMap/         # 热力图
│   │   │   └── index.ts
│   │   │
│   │   └── index.ts             # 组件总导出
│   │
│   ├── config/                   # 配置文件
│   │   ├── api.config.ts        # API配置
│   │   ├── theme.config.ts      # 主题配置
│   │   ├── navigation.config.ts # 导航配置
│   │   └── constants.ts         # 常量定义
│   │
│   ├── hooks/                    # 自定义Hooks
│   │   ├── useAuth.ts           # 认证Hook
│   │   ├── useTheme.ts          # 主题Hook
│   │   ├── useNetwork.ts        # 网络状态Hook
│   │   ├── useDebounce.ts       # 防抖Hook
│   │   ├── useInterval.ts       # 定时器Hook
│   │   └── index.ts
│   │
│   ├── models/                   # 数据模型/类型定义
│   │   ├── user.model.ts        # 用户模型
│   │   ├── vocabulary.model.ts  # 词汇模型
│   │   ├── card.model.ts        # 卡片模型
│   │   ├── note.model.ts        # 笔记模型
│   │   ├── plan.model.ts        # 计划模型
│   │   └── index.ts
│   │
│   ├── navigation/               # 导航配置
│   │   ├── types.ts             # 导航类型定义
│   │   ├── RootNavigator.tsx    # 根导航器
│   │   ├── AuthNavigator.tsx    # 认证导航
│   │   ├── MainNavigator.tsx    # 主导航(Tab)
│   │   ├── LearningNavigator.tsx # 学习模块导航
│   │   └── index.ts
│   │
│   ├── screens/                  # 页面组件
│   │   ├── auth/                # 认证页面
│   │   │   ├── LoginScreen/
│   │   │   ├── RegisterScreen/
│   │   │   └── index.ts
│   │   │
│   │   ├── home/                # 首页
│   │   │   ├── HomeScreen/
│   │   │   └── index.ts
│   │   │
│   │   ├── learning/            # 学习页面
│   │   │   ├── VocabularyScreen/
│   │   │   ├── GrammarScreen/
│   │   │   ├── ListeningScreen/
│   │   │   ├── SpeakingScreen/
│   │   │   └── index.ts
│   │   │
│   │   ├── memory/              # 复习页面
│   │   │   ├── ReviewListScreen/
│   │   │   ├── ReviewScreen/
│   │   │   ├── CardManageScreen/
│   │   │   └── index.ts
│   │   │
│   │   ├── planning/            # 计划页面
│   │   │   ├── GoalScreen/
│   │   │   ├── PlanScreen/
│   │   │   ├── TaskScreen/
│   │   │   └── index.ts
│   │   │
│   │   ├── notes/               # 笔记页面
│   │   │   ├── NoteListScreen/
│   │   │   ├── NoteEditorScreen/
│   │   │   └── index.ts
│   │   │
│   │   ├── ai/                  # AI助手页面
│   │   │   ├── AIChatScreen/
│   │   │   └── index.ts
│   │   │
│   │   ├── analytics/           # 数据统计页面
│   │   │   ├── StatisticsScreen/
│   │   │   └── index.ts
│   │   │
│   │   ├── profile/             # 个人中心页面
│   │   │   ├── ProfileScreen/
│   │   │   ├── SettingsScreen/
│   │   │   ├── AchievementScreen/
│   │   │   └── index.ts
│   │   │
│   │   └── index.ts
│   │
│   ├── services/                 # 业务服务层
│   │   ├── api/                 # API服务
│   │   │   ├── apiClient.ts     # Axios实例配置
│   │   │   ├── interceptors.ts  # 请求拦截器
│   │   │   └── index.ts
│   │   │
│   │   ├── ai/                  # AI服务
│   │   │   ├── AIService.ts     # AI服务接口
│   │   │   ├── OpenAIAdapter.ts # OpenAI适配器
│   │   │   └── index.ts
│   │   │
│   │   ├── storage/             # 存储服务
│   │   │   ├── MMKVStorage.ts   # MMKV存储
│   │   │   ├── SQLiteService.ts # SQLite服务
│   │   │   └── index.ts
│   │   │
│   │   ├── sync/                # 同步服务
│   │   │   ├── SyncManager.ts   # 同步管理器
│   │   │   ├── SyncQueue.ts     # 同步队列
│   │   │   └── index.ts
│   │   │
│   │   └── index.ts
│   │
│   ├── store/                    # Redux状态管理
│   │   ├── slices/              # Redux Slices
│   │   │   ├── authSlice.ts     # 认证状态
│   │   │   ├── userSlice.ts     # 用户信息
│   │   │   ├── learningSlice.ts # 学习状态
│   │   │   ├── memorySlice.ts   # 记忆状态
│   │   │   ├── planningSlice.ts # 规划状态
│   │   │   ├── notesSlice.ts    # 笔记状态
│   │   │   ├── aiSlice.ts       # AI状态
│   │   │   └── settingsSlice.ts # 设置状态
│   │   │
│   │   ├── api/                 # RTK Query API
│   │   │   ├── authApi.ts       # 认证API
│   │   │   ├── learningApi.ts   # 学习API
│   │   │   └── index.ts
│   │   │
│   │   ├── middleware/          # 中间件
│   │   │   ├── logger.ts        # 日志中间件
│   │   │   └── index.ts
│   │   │
│   │   ├── rootReducer.ts       # 根Reducer
│   │   ├── store.ts             # Store配置
│   │   └── index.ts
│   │
│   ├── styles/                   # 全局样式
│   │   ├── colors.ts            # 颜色定义
│   │   ├── typography.ts        # 字体样式
│   │   ├── spacing.ts           # 间距定义
│   │   ├── shadows.ts           # 阴影样式
│   │   └── index.ts
│   │
│   ├── types/                    # 全局类型定义
│   │   ├── api.types.ts         # API类型
│   │   ├── navigation.types.ts  # 导航类型
│   │   └── index.ts
│   │
│   ├── utils/                    # 工具函数
│   │   ├── algorithms/          # 算法实现
│   │   │   ├── sm2.ts           # SM-2算法
│   │   │   └── index.ts
│   │   ├── validators/          # 验证函数
│   │   │   ├── auth.validator.ts
│   │   │   └── index.ts
│   │   ├── formatters/          # 格式化函数
│   │   │   ├── date.formatter.ts
│   │   │   ├── number.formatter.ts
│   │   │   └── index.ts
│   │   ├── helpers/             # 辅助函数
│   │   │   ├── storage.helper.ts
│   │   │   ├── network.helper.ts
│   │   │   └── index.ts
│   │   └── index.ts
│   │
│   ├── App.tsx                   # 应用入口
│   └── index.ts                  # 导出入口
│
├── .env.development              # 开发环境变量
├── .env.production               # 生产环境变量
├── .eslintrc.js                  # ESLint配置
├── .prettierrc.js                # Prettier配置
├── tsconfig.json                 # TypeScript配置
├── babel.config.js               # Babel配置
├── metro.config.js               # Metro配置
├── package.json                  # 依赖配置
└── README.md                     # 项目文档
```

### 4.2 目录设计原则

#### 1. 模块化原则
- 每个功能模块独立目录
- 模块内部高内聚,模块间低耦合
- 便于团队协作和维护

#### 2. 分层原则
- UI层(components/screens)
- 业务层(services)
- 数据层(store/api/storage)
- 工具层(utils)

#### 3. 可扩展原则
- 新功能易于添加
- 不影响现有模块
- 支持代码复用

---

## 5. 核心模块设计

### 5.1 认证模块 (Auth Module)

#### 5.1.1 功能需求
- 手机号/邮箱登录注册
- 第三方登录(微信、Apple ID)
- JWT Token管理
- 自动登录
- 退出登录

#### 5.1.2 技术实现

**Redux Slice设计**:

```typescript
// src/store/slices/authSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  token: string | null;
  refreshToken: string | null;
  loading: boolean;
  error: string | null;
}

const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
  token: null,
  refreshToken: null,
  loading: false,
  error: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    loginStart(state) {
      state.loading = true;
      state.error = null;
    },
    loginSuccess(state, action: PayloadAction<{ user: User; token: string; refreshToken: string }>) {
      state.isAuthenticated = true;
      state.user = action.payload.user;
      state.token = action.payload.token;
      state.refreshToken = action.payload.refreshToken;
      state.loading = false;
    },
    loginFailure(state, action: PayloadAction<string>) {
      state.loading = false;
      state.error = action.payload;
    },
    logout(state) {
      state.isAuthenticated = false;
      state.user = null;
      state.token = null;
      state.refreshToken = null;
    },
  },
});

export const { loginStart, loginSuccess, loginFailure, logout } = authSlice.actions;
export default authSlice.reducer;
```

**RTK Query API**:

```typescript
// src/store/api/authApi.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { RootState } from '../store';

export const authApi = createApi({
  reducerPath: 'authApi',
  baseQuery: fetchBaseQuery({
    baseUrl: process.env.API_BASE_URL,
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.token;
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  endpoints: (builder) => ({
    login: builder.mutation<LoginResponse, LoginRequest>({
      query: (credentials) => ({
        url: '/auth/login',
        method: 'POST',
        body: credentials,
      }),
    }),
    register: builder.mutation<RegisterResponse, RegisterRequest>({
      query: (userData) => ({
        url: '/auth/register',
        method: 'POST',
        body: userData,
      }),
    }),
    refreshToken: builder.mutation<RefreshTokenResponse, RefreshTokenRequest>({
      query: (refreshToken) => ({
        url: '/auth/refresh',
        method: 'POST',
        body: { refreshToken },
      }),
    }),
  }),
});

export const { useLoginMutation, useRegisterMutation, useRefreshTokenMutation } = authApi;
```

**Token持久化**:

```typescript
// src/services/storage/TokenStorage.ts
import { MMKV } from 'react-native-mmkv';

const storage = new MMKV();

export class TokenStorage {
  private static TOKEN_KEY = 'auth_token';
  private static REFRESH_TOKEN_KEY = 'refresh_token';

  static saveToken(token: string, refreshToken: string): void {
    storage.set(this.TOKEN_KEY, token);
    storage.set(this.REFRESH_TOKEN_KEY, refreshToken);
  }

  static getToken(): string | undefined {
    return storage.getString(this.TOKEN_KEY);
  }

  static getRefreshToken(): string | undefined {
    return storage.getString(this.REFRESH_TOKEN_KEY);
  }

  static clearTokens(): void {
    storage.delete(this.TOKEN_KEY);
    storage.delete(this.REFRESH_TOKEN_KEY);
  }
}
```

### 5.2 记忆强化模块 (Memory Module)

#### 5.2.1 核心算法: SM-2

```typescript
// src/utils/algorithms/sm2.ts

/**
 * SM-2 间隔重复算法实现
 * 
 * 基于: SuperMemo-2 Algorithm
 * 论文: https://www.supermemo.com/en/archives1990-2015/english/ol/sm2
 */

export interface ReviewCard {
  id: string;
  easeFactor: number;      // 难度系数 (初始: 2.5)
  interval: number;        // 间隔天数
  repetitions: number;     // 复习次数
  nextReviewDate: Date;    // 下次复习日期
}

export interface ReviewResult {
  card: ReviewCard;
  quality: number;         // 评分 (0-5)
}

export class SM2Algorithm {
  /**
   * 计算下次复习时间
   * @param card 卡片信息
   * @param quality 评分 (0-5)
   *   5 - 完全记住,反应快速
   *   4 - 记住,但有些犹豫
   *   3 - 记住,但很费力
   *   2 - 有印象,但答错
   *   1 - 完全忘记
   */
  static calculateNextReview(card: ReviewCard, quality: number): ReviewCard {
    let { easeFactor, interval, repetitions } = card;

    // 更新难度系数
    easeFactor = Math.max(1.3, easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)));

    // 评分小于3,重新开始
    if (quality < 3) {
      repetitions = 0;
      interval = 1;
    } else {
      repetitions += 1;

      // 计算间隔
      if (repetitions === 1) {
        interval = 1;
      } else if (repetitions === 2) {
        interval = 6;
      } else {
        interval = Math.round(interval * easeFactor);
      }
    }

    // 计算下次复习日期
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + interval);

    return {
      ...card,
      easeFactor,
      interval,
      repetitions,
      nextReviewDate,
    };
  }

  /**
   * 获取今日待复习卡片
   */
  static getTodayReviewCards(cards: ReviewCard[]): ReviewCard[] {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    return cards.filter(card => {
      const reviewDate = new Date(card.nextReviewDate);
      reviewDate.setHours(0, 0, 0, 0);
      return reviewDate <= today;
    });
  }

  /**
   * 按优先级排序复习队列
   * 优先级: 逾期天数 > 难度系数低的卡片
   */
  static sortReviewQueue(cards: ReviewCard[]): ReviewCard[] {
    const today = new Date();
    
    return cards.sort((a, b) => {
      const aDaysOverdue = Math.floor((today.getTime() - a.nextReviewDate.getTime()) / (1000 * 60 * 60 * 24));
      const bDaysOverdue = Math.floor((today.getTime() - b.nextReviewDate.getTime()) / (1000 * 60 * 60 * 24));

      // 先按逾期天数排序
      if (aDaysOverdue !== bDaysOverdue) {
        return bDaysOverdue - aDaysOverdue;
      }

      // 再按难度系数排序 (难度系数低的优先)
      return a.easeFactor - b.easeFactor;
    });
  }
}
```

#### 5.2.2 SQLite数据库设计

```typescript
// src/services/storage/SQLiteService.ts
import SQLite from 'react-native-sqlite-storage';

export class MemoryDatabaseService {
  private db: SQLite.SQLiteDatabase | null = null;

  async init(): Promise<void> {
    this.db = await SQLite.openDatabase({
      name: 'learning_memory.db',
      location: 'default',
    });

    await this.createTables();
  }

  private async createTables(): Promise<void> {
    if (!this.db) return;

    // 卡片表
    await this.db.executeSql(`
      CREATE TABLE IF NOT EXISTS cards (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        front_content TEXT NOT NULL,
        back_content TEXT NOT NULL,
        card_type TEXT NOT NULL,
        tags TEXT,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        ease_factor REAL DEFAULT 2.5,
        interval INTEGER DEFAULT 1,
        repetitions INTEGER DEFAULT 0,
        next_review_date INTEGER NOT NULL,
        status TEXT DEFAULT 'learning',
        FOREIGN KEY(user_id) REFERENCES users(id)
      );
    `);

    // 复习历史表
    await this.db.executeSql(`
      CREATE TABLE IF NOT EXISTS review_history (
        id TEXT PRIMARY KEY,
        card_id TEXT NOT NULL,
        review_date INTEGER NOT NULL,
        quality INTEGER NOT NULL,
        interval INTEGER NOT NULL,
        ease_factor REAL NOT NULL,
        duration INTEGER,
        FOREIGN KEY(card_id) REFERENCES cards(id) ON DELETE CASCADE
      );
    `);

    // 创建索引
    await this.db.executeSql(`
      CREATE INDEX IF NOT EXISTS idx_cards_user_id ON cards(user_id);
      CREATE INDEX IF NOT EXISTS idx_cards_next_review_date ON cards(next_review_date);
      CREATE INDEX IF NOT EXISTS idx_review_history_card_id ON review_history(card_id);
    `);
  }

  // 获取今日待复习卡片
  async getTodayReviewCards(userId: string): Promise<ReviewCard[]> {
    if (!this.db) throw new Error('Database not initialized');

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayTimestamp = today.getTime();

    const [results] = await this.db.executeSql(
      `SELECT * FROM cards 
       WHERE user_id = ? AND next_review_date <= ? AND status != 'mastered'
       ORDER BY next_review_date ASC`,
      [userId, todayTimestamp]
    );

    return results.rows.raw();
  }

  // 保存复习结果
  async saveReviewResult(cardId: string, quality: number, newCardData: Partial<ReviewCard>): Promise<void> {
    if (!this.db) throw new Error('Database not initialized');

    await this.db.transaction(async (tx) => {
      // 更新卡片
      await tx.executeSql(
        `UPDATE cards SET 
         ease_factor = ?,
         interval = ?,
         repetitions = ?,
         next_review_date = ?,
         updated_at = ?
         WHERE id = ?`,
        [
          newCardData.easeFactor,
          newCardData.interval,
          newCardData.repetitions,
          newCardData.nextReviewDate?.getTime(),
          Date.now(),
          cardId,
        ]
      );

      // 记录复习历史
      await tx.executeSql(
        `INSERT INTO review_history (id, card_id, review_date, quality, interval, ease_factor, duration)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          generateId(),
          cardId,
          Date.now(),
          quality,
          newCardData.interval,
          newCardData.easeFactor,
          0, // duration可选
        ]
      );
    });
  }
}
```

#### 5.2.3 Redux状态管理

```typescript
// src/store/slices/memorySlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { MemoryDatabaseService } from '../../services/storage/SQLiteService';
import { SM2Algorithm } from '../../utils/algorithms/sm2';

interface MemoryState {
  reviewQueue: ReviewCard[];
  currentCardIndex: number;
  todayReviewedCount: number;
  statistics: {
    total: number;
    mastered: number;
    learning: number;
    new: number;
  };
  loading: boolean;
  error: string | null;
}

const initialState: MemoryState = {
  reviewQueue: [],
  currentCardIndex: 0,
  todayReviewedCount: 0,
  statistics: {
    total: 0,
    mastered: 0,
    learning: 0,
    new: 0,
  },
  loading: false,
  error: null,
};

// 异步Thunk: 加载今日复习队列
export const loadTodayReviewQueue = createAsyncThunk(
  'memory/loadTodayReviewQueue',
  async (userId: string) => {
    const dbService = new MemoryDatabaseService();
    await dbService.init();
    const cards = await dbService.getTodayReviewCards(userId);
    return SM2Algorithm.sortReviewQueue(cards);
  }
);

// 异步Thunk: 提交复习结果
export const submitReviewResult = createAsyncThunk(
  'memory/submitReviewResult',
  async ({ cardId, quality }: { cardId: string; quality: number }, { getState }) => {
    const state = getState() as RootState;
    const card = state.memory.reviewQueue[state.memory.currentCardIndex];
    
    // 计算下次复习时间
    const updatedCard = SM2Algorithm.calculateNextReview(card, quality);
    
    // 保存到数据库
    const dbService = new MemoryDatabaseService();
    await dbService.init();
    await dbService.saveReviewResult(cardId, quality, updatedCard);
    
    return updatedCard;
  }
);

const memorySlice = createSlice({
  name: 'memory',
  initialState,
  reducers: {
    nextCard(state) {
      if (state.currentCardIndex < state.reviewQueue.length - 1) {
        state.currentCardIndex += 1;
      }
    },
    resetReview(state) {
      state.currentCardIndex = 0;
      state.todayReviewedCount = 0;
    },
  },
  extraReducers: (builder) => {
    builder
      // 加载复习队列
      .addCase(loadTodayReviewQueue.pending, (state) => {
        state.loading = true;
      })
      .addCase(loadTodayReviewQueue.fulfilled, (state, action) => {
        state.reviewQueue = action.payload;
        state.loading = false;
      })
      .addCase(loadTodayReviewQueue.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to load review queue';
      })
      // 提交复习结果
      .addCase(submitReviewResult.fulfilled, (state, action) => {
        state.todayReviewedCount += 1;
        // 更新队列中的卡片
        state.reviewQueue[state.currentCardIndex] = action.payload;
      });
  },
});

export const { nextCard, resetReview } = memorySlice.actions;
export default memorySlice.reducer;
```

### 5.3 学习规划模块 (Planning Module)

#### 5.3.1 AI计划生成服务

```typescript
// src/services/ai/PlanningAIService.ts
import { OpenAIAdapter } from './OpenAIAdapter';

export interface PlanGenerationRequest {
  goalType: string;        // 目标类型: 'exam' | 'skill' | 'habit'
  targetDate: Date;        // 目标日期
  currentLevel: string;    // 当前水平
  studyTime: number;       // 每日学习时间(分钟)
  preferences: string[];   // 偏好设置
}

export interface LearningPlan {
  id: string;
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  milestones: Milestone[];
  weeklyTasks: WeeklyTask[];
  estimatedProgress: number[];
}

export class PlanningAIService {
  private aiAdapter: OpenAIAdapter;

  constructor() {
    this.aiAdapter = new OpenAIAdapter();
  }

  /**
   * AI生成学习计划
   */
  async generatePlan(request: PlanGenerationRequest): Promise<LearningPlan> {
    const prompt = this.buildPlanPrompt(request);

    const response = await this.aiAdapter.chat({
      messages: [
        {
          role: 'system',
          content: '你是一位专业的学习规划专家,擅长根据用户的目标和情况制定科学合理的学习计划。',
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
      temperature: 0.7,
      responseFormat: 'json', // 要求返回JSON格式
    });

    return this.parsePlanFromAI(response);
  }

  /**
   * 构建AI提示词
   */
  private buildPlanPrompt(request: PlanGenerationRequest): string {
    const daysDiff = Math.ceil((request.targetDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24));

    return `
请根据以下信息生成一个详细的学习计划:

目标类型: ${request.goalType}
目标日期: ${request.targetDate.toLocaleDateString()} (还有${daysDiff}天)
当前水平: ${request.currentLevel}
每日可学习时间: ${request.studyTime}分钟
用户偏好: ${request.preferences.join(', ')}

要求:
1. 计划应该循序渐进,符合学习规律
2. 合理分配每周任务量
3. 设置3-5个里程碑节点
4. 考虑休息和复习时间
5. 提供预期进度曲线

请以JSON格式返回,包含以下字段:
{
  "title": "计划标题",
  "description": "计划描述",
  "milestones": [
    {
      "week": 1,
      "title": "里程碑标题",
      "description": "里程碑描述",
      "targetCompletion": 0.2
    }
  ],
  "weeklyTasks": [
    {
      "week": 1,
      "tasks": [
        {
          "title": "任务标题",
          "description": "任务描述",
          "estimatedTime": 30,
          "priority": "high"
        }
      ]
    }
  ]
}
    `.trim();
  }

  /**
   * 解析AI返回的计划
   */
  private parsePlanFromAI(response: string): LearningPlan {
    const data = JSON.parse(response);
    
    return {
      id: generateId(),
      title: data.title,
      description: data.description,
      startDate: new Date(),
      endDate: new Date(), // 根据实际情况计算
      milestones: data.milestones,
      weeklyTasks: data.weeklyTasks,
      estimatedProgress: data.estimatedProgress || [],
    };
  }
}
```

### 5.4 AI助手模块

#### 5.4.1 OpenAI适配器实现

```typescript
// src/services/ai/OpenAIAdapter.ts
import axios, { AxiosInstance } from 'axios';

export interface ChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface ChatRequest {
  messages: ChatMessage[];
  temperature?: number;
  maxTokens?: number;
  stream?: boolean;
  responseFormat?: 'text' | 'json';
}

export interface ChatResponse {
  id: string;
  content: string;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

export class OpenAIAdapter {
  private client: AxiosInstance;
  private model: string = 'gpt-4-turbo-preview';

  constructor() {
    this.client = axios.create({
      baseURL: 'https://api.openai.com/v1',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      timeout: 60000, // 60秒超时
    });
  }

  /**
   * 发送聊天请求
   */
  async chat(request: ChatRequest): Promise<string> {
    try {
      const response = await this.client.post('/chat/completions', {
        model: this.model,
        messages: request.messages,
        temperature: request.temperature ?? 0.7,
        max_tokens: request.maxTokens ?? 2000,
        stream: request.stream ?? false,
        response_format: request.responseFormat === 'json' 
          ? { type: 'json_object' } 
          : undefined,
      });

      return response.data.choices[0].message.content;
    } catch (error) {
      console.error('OpenAI API Error:', error);
      throw new Error('AI服务暂时不可用,请稍后重试');
    }
  }

  /**
   * 流式聊天(用于实时显示AI回答)
   */
  async chatStream(
    request: ChatRequest,
    onChunk: (chunk: string) => void
  ): Promise<void> {
    try {
      const response = await this.client.post(
        '/chat/completions',
        {
          model: this.model,
          messages: request.messages,
          temperature: request.temperature ?? 0.7,
          max_tokens: request.maxTokens ?? 2000,
          stream: true,
        },
        {
          responseType: 'stream',
        }
      );

      // 处理流式响应
      response.data.on('data', (chunk: Buffer) => {
        const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');
        
        for (const line of lines) {
          if (line.includes('[DONE]')) return;
          
          if (line.startsWith('data: ')) {
            const jsonStr = line.substring(6);
            try {
              const json = JSON.parse(jsonStr);
              const content = json.choices[0]?.delta?.content;
              if (content) {
                onChunk(content);
              }
            } catch (e) {
              // 忽略解析错误
            }
          }
        }
      });
    } catch (error) {
      console.error('OpenAI Stream Error:', error);
      throw new Error('AI服务暂时不可用');
    }
  }
}
```

#### 5.4.2 AI缓存策略

```typescript
// src/services/ai/AICacheService.ts
import { MMKV } from 'react-native-mmkv';
import crypto from 'crypto';

const cache = new MMKV({ id: 'ai-cache' });

export class AICacheService {
  private static CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7天

  /**
   * 生成缓存键
   */
  private static generateCacheKey(question: string): string {
    return crypto.createHash('md5').update(question.trim().toLowerCase()).digest('hex');
  }

  /**
   * 获取缓存
   */
  static get(question: string): string | null {
    const key = this.generateCacheKey(question);
    const cached = cache.getString(key);
    
    if (!cached) return null;

    try {
      const data = JSON.parse(cached);
      
      // 检查是否过期
      if (Date.now() - data.timestamp > this.CACHE_EXPIRY) {
        cache.delete(key);
        return null;
      }

      return data.answer;
    } catch (error) {
      return null;
    }
  }

  /**
   * 设置缓存
   */
  static set(question: string, answer: string): void {
    const key = this.generateCacheKey(question);
    const data = {
      answer,
      timestamp: Date.now(),
    };
    cache.set(key, JSON.stringify(data));
  }

  /**
   * 清除过期缓存
   */
  static clearExpired(): void {
    const keys = cache.getAllKeys();
    const now = Date.now();

    keys.forEach(key => {
      const cached = cache.getString(key);
      if (!cached) return;

      try {
        const data = JSON.parse(cached);
        if (now - data.timestamp > this.CACHE_EXPIRY) {
          cache.delete(key);
        }
      } catch (error) {
        cache.delete(key);
      }
    });
  }
}
```

---

## 6. 数据层架构

### 6.1 数据库设计

#### 6.1.1 完整数据库Schema

```sql
-- 用户表
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  username TEXT UNIQUE NOT NULL,
  email TEXT UNIQUE,
  phone TEXT UNIQUE,
  avatar_url TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- 学习卡片表
CREATE TABLE cards (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  front_content TEXT NOT NULL,
  back_content TEXT NOT NULL,
  card_type TEXT NOT NULL, -- 'vocabulary', 'grammar', 'custom'
  tags TEXT, -- JSON数组
  source TEXT, -- 卡片来源
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  ease_factor REAL DEFAULT 2.5,
  interval INTEGER DEFAULT 1,
  repetitions INTEGER DEFAULT 0,
  next_review_date INTEGER NOT NULL,
  status TEXT DEFAULT 'learning', -- 'new', 'learning', 'reviewing', 'mastered'
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- 复习历史表
CREATE TABLE review_history (
  id TEXT PRIMARY KEY,
  card_id TEXT NOT NULL,
  review_date INTEGER NOT NULL,
  quality INTEGER NOT NULL, -- 0-5评分
  interval INTEGER NOT NULL,
  ease_factor REAL NOT NULL,
  duration INTEGER, -- 复习用时(秒)
  FOREIGN KEY(card_id) REFERENCES cards(id) ON DELETE CASCADE
);

-- 学习目标表
CREATE TABLE goals (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  goal_type TEXT NOT NULL, -- 'exam', 'skill', 'habit'
  target_date INTEGER,
  current_progress REAL DEFAULT 0,
  status TEXT DEFAULT 'active', -- 'active', 'paused', 'completed', 'cancelled'
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- 学习计划表
CREATE TABLE plans (
  id TEXT PRIMARY KEY,
  goal_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  start_date INTEGER NOT NULL,
  end_date INTEGER NOT NULL,
  ai_generated BOOLEAN DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY(goal_id) REFERENCES goals(id) ON DELETE CASCADE,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- 学习任务表
CREATE TABLE tasks (
  id TEXT PRIMARY KEY,
  plan_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  task_type TEXT NOT NULL, -- 'vocabulary', 'listening', 'review', etc.
  scheduled_date INTEGER NOT NULL,
  completed_at INTEGER,
  estimated_duration INTEGER, -- 预计时长(分钟)
  actual_duration INTEGER, -- 实际时长(分钟)
  status TEXT DEFAULT 'pending', -- 'pending', 'in_progress', 'completed', 'skipped'
  priority TEXT DEFAULT 'medium', -- 'low', 'medium', 'high'
  created_at INTEGER NOT NULL,
  FOREIGN KEY(plan_id) REFERENCES plans(id) ON DELETE CASCADE,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- 笔记表
CREATE TABLE notes (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  title TEXT NOT NULL,
  content TEXT NOT NULL, -- Markdown内容
  folder TEXT, -- 文件夹路径
  tags TEXT, -- JSON数组
  note_type TEXT DEFAULT 'general', -- 'course', 'error', 'insight', 'general'
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- 学习记录表
CREATE TABLE study_sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  session_type TEXT NOT NULL, -- 'vocabulary', 'grammar', 'listening', etc.
  duration INTEGER NOT NULL, -- 时长(秒)
  items_count INTEGER, -- 学习项目数量
  accuracy REAL, -- 准确率
  start_time INTEGER NOT NULL,
  end_time INTEGER NOT NULL,
  metadata TEXT, -- JSON额外数据
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- AI对话历史表
CREATE TABLE ai_conversations (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  conversation_type TEXT NOT NULL, -- 'qa', 'practice', 'correction'
  messages TEXT NOT NULL, -- JSON消息数组
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- 同步队列表 (离线数据同步)
CREATE TABLE sync_queue (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  entity_type TEXT NOT NULL, -- 'card', 'review', 'note', etc.
  entity_id TEXT NOT NULL,
  operation TEXT NOT NULL, -- 'create', 'update', 'delete'
  data TEXT NOT NULL, -- JSON数据
  created_at INTEGER NOT NULL,
  synced BOOLEAN DEFAULT 0,
  synced_at INTEGER,
  retry_count INTEGER DEFAULT 0,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

-- 创建索引
CREATE INDEX idx_cards_user_id ON cards(user_id);
CREATE INDEX idx_cards_next_review_date ON cards(next_review_date);
CREATE INDEX idx_cards_status ON cards(status);
CREATE INDEX idx_review_history_card_id ON review_history(card_id);
CREATE INDEX idx_review_history_date ON review_history(review_date);
CREATE INDEX idx_goals_user_id ON goals(user_id);
CREATE INDEX idx_plans_goal_id ON plans(goal_id);
CREATE INDEX idx_tasks_plan_id ON tasks(plan_id);
CREATE INDEX idx_tasks_scheduled_date ON tasks(scheduled_date);
CREATE INDEX idx_notes_user_id ON notes(user_id);
CREATE INDEX idx_study_sessions_user_id ON study_sessions(user_id);
CREATE INDEX idx_study_sessions_start_time ON study_sessions(start_time);
CREATE INDEX idx_ai_conversations_user_id ON ai_conversations(user_id);
CREATE INDEX idx_sync_queue_synced ON sync_queue(synced);
```

### 6.2 数据同步机制

#### 6.2.1 同步管理器

```typescript
// src/services/sync/SyncManager.ts
import NetInfo from '@react-native-community/netinfo';
import { MemoryDatabaseService } from '../storage/SQLiteService';
import { apiClient } from '../api/apiClient';

export interface SyncTask {
  id: string;
  userId: string;
  entityType: string;
  entityId: string;
  operation: 'create' | 'update' | 'delete';
  data: any;
  createdAt: number;
  retryCount: number;
}

export class SyncManager {
  private db: MemoryDatabaseService;
  private isOnline: boolean = false;
  private isSyncing: boolean = false;
  private syncInterval: NodeJS.Timeout | null = null;

  constructor() {
    this.db = new MemoryDatabaseService();
    this.init();
  }

  /**
   * 初始化同步管理器
   */
  async init(): Promise<void> {
    await this.db.init();
    
    // 监听网络状态
    NetInfo.addEventListener(state => {
      const wasOffline = !this.isOnline;
      this.isOnline = state.isConnected ?? false;

      // 网络恢复时立即同步
      if (wasOffline && this.isOnline) {
        this.syncNow();
      }
    });

    // 定期同步(每5分钟)
    this.startPeriodicSync();
  }

  /**
   * 添加同步任务
   */
  async addSyncTask(task: Omit<SyncTask, 'id' | 'createdAt' | 'retryCount'>): Promise<void> {
    const syncTask: SyncTask = {
      ...task,
      id: generateId(),
      createdAt: Date.now(),
      retryCount: 0,
    };

    // 保存到同步队列
    await this.db.executeSql(
      `INSERT INTO sync_queue (id, user_id, entity_type, entity_id, operation, data, created_at, synced, retry_count)
       VALUES (?, ?, ?, ?, ?, ?, ?, 0, 0)`,
      [
        syncTask.id,
        syncTask.userId,
        syncTask.entityType,
        syncTask.entityId,
        syncTask.operation,
        JSON.stringify(syncTask.data),
        syncTask.createdAt,
      ]
    );

    // 如果在线,立即尝试同步
    if (this.isOnline && !this.isSyncing) {
      this.syncNow();
    }
  }

  /**
   * 立即执行同步
   */
  async syncNow(): Promise<void> {
    if (this.isSyncing || !this.isOnline) return;

    this.isSyncing = true;

    try {
      // 获取待同步任务
      const tasks = await this.getPendingSyncTasks();

      for (const task of tasks) {
        try {
          await this.syncTask(task);
          
          // 标记为已同步
          await this.markTaskAsSynced(task.id);
        } catch (error) {
          // 增加重试次数
          await this.incrementRetryCount(task.id);
          
          // 超过最大重试次数,记录错误
          if (task.retryCount >= 3) {
            console.error('Sync task failed after 3 retries:', task);
          }
        }
      }
    } finally {
      this.isSyncing = false;
    }
  }

  /**
   * 同步单个任务
   */
  private async syncTask(task: SyncTask): Promise<void> {
    const endpoint = this.getEndpoint(task.entityType);
    
    switch (task.operation) {
      case 'create':
        await apiClient.post(endpoint, task.data);
        break;
      case 'update':
        await apiClient.put(`${endpoint}/${task.entityId}`, task.data);
        break;
      case 'delete':
        await apiClient.delete(`${endpoint}/${task.entityId}`);
        break;
    }
  }

  /**
   * 获取待同步任务
   */
  private async getPendingSyncTasks(): Promise<SyncTask[]> {
    const [results] = await this.db.executeSql(
      `SELECT * FROM sync_queue 
       WHERE synced = 0 AND retry_count < 3
       ORDER BY created_at ASC
       LIMIT 50`
    );

    return results.rows.raw().map((row: any) => ({
      ...row,
      data: JSON.parse(row.data),
    }));
  }

  /**
   * 标记任务为已同步
   */
  private async markTaskAsSynced(taskId: string): Promise<void> {
    await this.db.executeSql(
      `UPDATE sync_queue SET synced = 1, synced_at = ? WHERE id = ?`,
      [Date.now(), taskId]
    );
  }

  /**
   * 增加重试次数
   */
  private async incrementRetryCount(taskId: string): Promise<void> {
    await this.db.executeSql(
      `UPDATE sync_queue SET retry_count = retry_count + 1 WHERE id = ?`,
      [taskId]
    );
  }

  /**
   * 定期同步
   */
  private startPeriodicSync(): void {
    this.syncInterval = setInterval(() => {
      if (this.isOnline) {
        this.syncNow();
      }
    }, 5 * 60 * 1000); // 5分钟
  }

  /**
   * 停止同步
   */
  stopPeriodicSync(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }
  }

  /**
   * 获取API端点
   */
  private getEndpoint(entityType: string): string {
    const endpoints: Record<string, string> = {
      card: '/api/cards',
      review: '/api/reviews',
      note: '/api/notes',
      goal: '/api/goals',
      plan: '/api/plans',
      task: '/api/tasks',
    };
    return endpoints[entityType] || '/api/sync';
  }
}

// 单例模式
export const syncManager = new SyncManager();
```

---

## 7. UI层架构

### 7.1 设计系统实现

#### 7.1.1 主题配置

```typescript
// src/styles/theme.ts
export const lightTheme = {
  colors: {
    primary: '#4A90E2',
    primaryLight: '#5FB3F6',
    primaryDark: '#2C5F8D',
    
    secondary: '#722ED1', // AI助手紫色
    
    success: '#52C41A',
    warning: '#FAAD14',
    error: '#F5222D',
    info: '#1890FF',
    
    background: '#F7F9FC',
    surface: '#FFFFFF',
    
    textPrimary: '#1A1A1A',
    textSecondary: '#8C8C8C',
    textDisabled: '#BFBFBF',
    
    border: '#E8E8E8',
    divider: '#F0F0F0',
    
    overlay: 'rgba(0, 0, 0, 0.5)',
  },
  
  spacing: {
    xs: 4,
    sm: 8,
    md: 12,
    lg: 16,
    xl: 24,
    xxl: 32,
  },
  
  borderRadius: {
    sm: 6,
    md: 8,
    lg: 12,
    xl: 16,
    round: 9999,
  },
  
  typography: {
    h1: {
      fontSize: 24,
      fontWeight: '700',
      lineHeight: 32,
    },
    h2: {
      fontSize: 20,
      fontWeight: '600',
      lineHeight: 28,
    },
    h3: {
      fontSize: 18,
      fontWeight: '600',
      lineHeight: 24,
    },
    body: {
      fontSize: 16,
      fontWeight: '400',
      lineHeight: 24,
    },
    bodySmall: {
      fontSize: 14,
      fontWeight: '400',
      lineHeight: 20,
    },
    caption: {
      fontSize: 12,
      fontWeight: '400',
      lineHeight: 16,
    },
  },
  
  shadows: {
    small: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.1,
      shadowRadius: 4,
      elevation: 2,
    },
    medium: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 4,
    },
    large: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 8 },
      shadowOpacity: 0.2,
      shadowRadius: 16,
      elevation: 8,
    },
  },
};

export const darkTheme: Theme = {
  ...lightTheme,
  colors: {
    ...lightTheme.colors,
    background: '#1A1A1A',
    surface: '#2A2A2A',
    textPrimary: '#FFFFFF',
    textSecondary: '#B0B0B0',
    border: '#3A3A3A',
    divider: '#303030',
  },
};

export type Theme = typeof lightTheme;
```

#### 7.1.2 通用组件示例

**Button组件**:

```typescript
// src/components/common/Button/index.tsx
import React from 'react';
import { TouchableOpacity, Text, ActivityIndicator, StyleSheet } from 'react-native';
import { useTheme } from '../../../hooks/useTheme';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary' | 'outline' | 'text';
  size?: 'small' | 'medium' | 'large';
  loading?: boolean;
  disabled?: boolean;
  fullWidth?: boolean;
  icon?: React.ReactNode;
}

export const Button: React.FC<ButtonProps> = ({
  title,
  onPress,
  variant = 'primary',
  size = 'medium',
  loading = false,
  disabled = false,
  fullWidth = false,
  icon,
}) => {
  const { theme } = useTheme();

  const getButtonStyle = () => {
    const baseStyle = {
      backgroundColor: theme.colors.primary,
      borderRadius: theme.borderRadius.md,
      paddingHorizontal: theme.spacing.lg,
      paddingVertical: theme.spacing.md,
      flexDirection: 'row' as const,
      alignItems: 'center' as const,
      justifyContent: 'center' as const,
      ...theme.shadows.small,
    };

    if (variant === 'outline') {
      return {
        ...baseStyle,
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: theme.colors.primary,
        shadowOpacity: 0,
        elevation: 0,
      };
    }

    if (variant === 'text') {
      return {
        ...baseStyle,
        backgroundColor: 'transparent',
        shadowOpacity: 0,
        elevation: 0,
      };
    }

    if (variant === 'secondary') {
      return {
        ...baseStyle,
        backgroundColor: theme.colors.surface,
        borderWidth: 1,
        borderColor: theme.colors.border,
      };
    }

    return baseStyle;
  };

  const getTextStyle = () => {
    const baseTextStyle = {
      fontSize: 16,
      fontWeight: '600' as const,
      color: '#FFFFFF',
    };

    if (variant === 'outline' || variant === 'text') {
      return {
        ...baseTextStyle,
        color: theme.colors.primary,
      };
    }

    if (variant === 'secondary') {
      return {
        ...baseTextStyle,
        color: theme.colors.textPrimary,
      };
    }

    return baseTextStyle;
  };

  return (
    <TouchableOpacity
      style={[
        getButtonStyle(),
        fullWidth && { width: '100%' },
        disabled && { opacity: 0.5 },
      ]}
      onPress={onPress}
      disabled={disabled || loading}
      activeOpacity={0.7}
    >
      {loading ? (
        <ActivityIndicator color={variant === 'primary' ? '#FFFFFF' : theme.colors.primary} />
      ) : (
        <>
          {icon && <View style={{ marginRight: 8 }}>{icon}</View>}
          <Text style={getTextStyle()}>{title}</Text>
        </>
      )}
    </TouchableOpacity>
  );
};
```

**Card组件**:

```typescript
// src/components/common/Card/index.tsx
import React from 'react';
import { View, StyleSheet, ViewStyle } from 'react-native';
import { useTheme } from '../../../hooks/useTheme';

interface CardProps {
  children: React.ReactNode;
  style?: ViewStyle;
  variant?: 'default' | 'elevated' | 'outlined';
  padding?: number;
}

export const Card: React.FC<CardProps> = ({
  children,
  style,
  variant = 'default',
  padding,
}) => {
  const { theme } = useTheme();

  const getCardStyle = (): ViewStyle => {
    const baseStyle: ViewStyle = {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.borderRadius.lg,
      padding: padding ?? theme.spacing.lg,
    };

    if (variant === 'elevated') {
      return {
        ...baseStyle,
        ...theme.shadows.medium,
      };
    }

    if (variant === 'outlined') {
      return {
        ...baseStyle,
        borderWidth: 1,
        borderColor: theme.colors.border,
      };
    }

    return {
      ...baseStyle,
      ...theme.shadows.small,
    };
  };

  return <View style={[getCardStyle(), style]}>{children}</View>;
};
```

### 7.2 屏幕组件示例

**HomeScreen**:

```typescript
// src/screens/home/HomeScreen/index.tsx
import React, { useEffect } from 'react';
import { View, Text, ScrollView, StyleSheet } from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { useNavigation } from '@react-navigation/native';
import { Card, Button } from '../../../components/common';
import { loadTodayReviewQueue } from '../../../store/slices/memorySlice';
import { RootState } from '../../../store';
import { useTheme } from '../../../hooks/useTheme';

export const HomeScreen: React.FC = () => {
  const { theme } = useTheme();
  const dispatch = useDispatch();
  const navigation = useNavigation();
  
  const { user } = useSelector((state: RootState) => state.auth);
  const { reviewQueue, todayReviewedCount } = useSelector((state: RootState) => state.memory);
  const { todayTasks } = useSelector((state: RootState) => state.planning);

  useEffect(() => {
    if (user?.id) {
      dispatch(loadTodayReviewQueue(user.id));
    }
  }, [user]);

  const greeting = () => {
    const hour = new Date().getHours();
    if (hour < 12) return '早上好';
    if (hour < 18) return '下午好';
    return '晚上好';
  };

  return (
    <ScrollView style={styles.container}>
      {/* 问候语 */}
      <View style={styles.header}>
        <Text style={[theme.typography.h2, { color: theme.colors.textPrimary }]}>
          {greeting()}, {user?.username}
        </Text>
        <Text style={[theme.typography.bodySmall, { color: theme.colors.textSecondary }]}>
          今天也要加油学习哦!
        </Text>
      </View>

      {/* 连续学习打卡 */}
      <Card variant="elevated" style={styles.streakCard}>
        <View style={styles.streakContent}>
          <Text style={{ fontSize: 32 }}>🔥</Text>
          <View style={{ flex: 1, marginLeft: theme.spacing.md }}>
            <Text style={[theme.typography.h3, { color: theme.colors.textPrimary }]}>
              连续学习 15 天
            </Text>
            <View style={styles.progressBar}>
              <View style={[styles.progressFill, { width: '75%', backgroundColor: theme.colors.primary }]} />
            </View>
            <Text style={[theme.typography.caption, { color: theme.colors.textSecondary }]}>
              今日完成度: 75%
            </Text>
          </View>
        </View>
      </Card>

      {/* 今日任务 */}
      <View style={styles.section}>
        <View style={styles.sectionHeader}>
          <Text style={[theme.typography.h3, { color: theme.colors.textPrimary }]}>
            📚 今日任务
          </Text>
          <Text style={[theme.typography.bodySmall, { color: theme.colors.textSecondary }]}>
            {todayTasks.filter(t => t.status === 'completed').length}/{todayTasks.length}
          </Text>
        </View>

        {/* 待复习卡片 */}
        {reviewQueue.length > 0 && (
          <Card style={styles.taskCard}>
            <View style={styles.taskHeader}>
              <Text>⏱</Text>
              <View style={{ flex: 1, marginLeft: theme.spacing.sm }}>
                <Text style={[theme.typography.body, { color: theme.colors.textPrimary }]}>
                  复习卡片 {reviewQueue.length}张
                </Text>
                <Text style={[theme.typography.caption, { color: theme.colors.textSecondary }]}>
                  约需 {Math.ceil(reviewQueue.length * 0.5)} 分钟
                </Text>
              </View>
            </View>
            <Button
              title="立即复习"
              onPress={() => navigation.navigate('Review')}
              fullWidth
            />
          </Card>
        )}

        {/* 其他任务 */}
        {todayTasks.map(task => (
          <Card key={task.id} style={styles.taskCard}>
            <View style={styles.taskHeader}>
              <Text>{task.icon}</Text>
              <View style={{ flex: 1, marginLeft: theme.spacing.sm }}>
                <Text style={[theme.typography.body, { color: theme.colors.textPrimary }]}>
                  {task.title}
                </Text>
                <Text style={[theme.typography.caption, { color: theme.colors.textSecondary }]}>
                  {task.status === 'completed' ? '已完成' : '待开始'}
                </Text>
              </View>
            </View>
          </Card>
        ))}
      </View>

      {/* 学习目标 */}
      <View style={styles.section}>
        <Text style={[theme.typography.h3, { color: theme.colors.textPrimary }]}>
          🎯 学习目标
        </Text>
        <Card variant="elevated" style={styles.goalCard}>
          <Text style={[theme.typography.h3, { color: theme.colors.textPrimary }]}>
            雅思7.5分 备考
          </Text>
          <Text style={[theme.typography.bodySmall, { color: theme.colors.textSecondary, marginTop: 4 }]}>
            距离目标还有 165 天
          </Text>
          <View style={styles.progressBar}>
            <View style={[styles.progressFill, { width: '25%', backgroundColor: theme.colors.primary }]} />
          </View>
          <Text style={[theme.typography.caption, { color: theme.colors.textSecondary, marginTop: 4 }]}>
            25% 完成
          </Text>
        </Card>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F7F9FC',
  },
  header: {
    padding: 16,
  },
  streakCard: {
    marginHorizontal: 16,
    marginBottom: 16,
  },
  streakContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  progressBar: {
    height: 6,
    backgroundColor: '#E8E8E8',
    borderRadius: 3,
    marginTop: 8,
    marginBottom: 4,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    borderRadius: 3,
  },
  section: {
    marginHorizontal: 16,
    marginBottom: 24,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  taskCard: {
    marginBottom: 12,
  },
  taskHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  goalCard: {
    marginTop: 12,
  },
});
```

---

## 8. 路由与导航

### 8.1 导航类型定义

```typescript
// src/navigation/types.ts
import { BottomTabScreenProps } from '@react-navigation/bottom-tabs';
import { CompositeScreenProps } from '@react-navigation/native';
import { StackScreenProps } from '@react-navigation/stack';

// 根导航参数
export type RootStackParamList = {
  Auth: undefined;
  Main: undefined;
};

// 认证导航参数
export type AuthStackParamList = {
  Login: undefined;
  Register: undefined;
  ForgotPassword: undefined;
};

// 主导航Tab参数
export type MainTabParamList = {
  Home: undefined;
  Review: undefined;
  Planning: undefined;
  Notes: undefined;
  Profile: undefined;
};

// 学习模块导航参数
export type LearningStackParamList = {
  VocabularyList: undefined;
  VocabularyDetail: { wordId: string };
  GrammarList: undefined;
  GrammarDetail: { grammarId: string };
  ListeningList: undefined;
  ListeningDetail: { audioId: string };
};

// 复习模块导航参数
export type ReviewStackParamList = {
  ReviewList: undefined;
  ReviewSession: { deckId?: string };
  ReviewComplete: { statistics: ReviewStatistics };
  CardManage: undefined;
  CardCreate: undefined;
  CardEdit: { cardId: string };
};

// 类型组合
export type HomeScreenProps = CompositeScreenProps<
  BottomTabScreenProps<MainTabParamList, 'Home'>,
  StackScreenProps<RootStackParamList>
>;

export type ReviewScreenProps = CompositeScreenProps<
  StackScreenProps<ReviewStackParamList, 'ReviewSession'>,
  CompositeScreenProps<
    BottomTabScreenProps<MainTabParamList>,
    StackScreenProps<RootStackParamList>
  >
>;
```

### 8.2 导航器配置

**RootNavigator**:

```typescript
// src/navigation/RootNavigator.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { useSelector } from 'react-redux';
import { RootState } from '../store';
import { AuthNavigator } from './AuthNavigator';
import { MainNavigator } from './MainNavigator';
import { RootStackParamList } from './types';

const Stack = createStackNavigator<RootStackParamList>();

export const RootNavigator: React.FC = () => {
  const { isAuthenticated } = useSelector((state: RootState) => state.auth);

  return (
    <NavigationContainer>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        {isAuthenticated ? (
          <Stack.Screen name="Main" component={MainNavigator} />
        ) : (
          <Stack.Screen name="Auth" component={AuthNavigator} />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};
```

**MainNavigator (Tab)**:

```typescript
// src/navigation/MainNavigator.tsx
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import Icon from 'react-native-vector-icons/Ionicons';
import { useTheme } from '../hooks/useTheme';
import { MainTabParamList } from './types';

// Screens
import { HomeScreen } from '../screens/home/HomeScreen';
import { ReviewListScreen } from '../screens/memory/ReviewListScreen';
import { PlanScreen } from '../screens/planning/PlanScreen';
import { NoteListScreen } from '../screens/notes/NoteListScreen';
import { ProfileScreen } from '../screens/profile/ProfileScreen';

const Tab = createBottomTabNavigator<MainTabParamList>();

export const MainNavigator: React.FC = () => {
  const { theme } = useTheme();

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        headerShown: false,
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string;

          switch (route.name) {
            case 'Home':
              iconName = focused ? 'home' : 'home-outline';
              break;
            case 'Review':
              iconName = focused ? 'repeat' : 'repeat-outline';
              break;
            case 'Planning':
              iconName = focused ? 'calendar' : 'calendar-outline';
              break;
            case 'Notes':
              iconName = focused ? 'document-text' : 'document-text-outline';
              break;
            case 'Profile':
              iconName = focused ? 'person' : 'person-outline';
              break;
            default:
              iconName = 'help-outline';
          }

          return <Icon name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.textSecondary,
        tabBarStyle: {
          backgroundColor: theme.colors.surface,
          borderTopColor: theme.colors.border,
        },
        tabBarLabelStyle: {
          fontSize: 12,
        },
      })}
    >
      <Tab.Screen 
        name="Home" 
        component={HomeScreen}
        options={{ tabBarLabel: '学习' }}
      />
      <Tab.Screen 
        name="Review" 
        component={ReviewListScreen}
        options={{ tabBarLabel: '复习' }}
      />
      <Tab.Screen 
        name="Planning" 
        component={PlanScreen}
        options={{ tabBarLabel: '计划' }}
      />
      <Tab.Screen 
        name="Notes" 
        component={NoteListScreen}
        options={{ tabBarLabel: '笔记' }}
      />
      <Tab.Screen 
        name="Profile" 
        component={ProfileScreen}
        options={{ tabBarLabel: '我的' }}
      />
    </Tab.Navigator>
  );
};
```

---

## 9. 状态管理方案

### 9.1 Store配置

```typescript
// src/store/store.ts
import { configureStore, combineReducers } from '@reduxjs/toolkit';
import { 
  persistStore, 
  persistReducer,
  FLUSH,
  REHYDRATE,
  PAUSE,
  PERSIST,
  PURGE,
  REGISTER,
} from 'redux-persist';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Reducers
import authReducer from './slices/authSlice';
import userReducer from './slices/userSlice';
import learningReducer from './slices/learningSlice';
import memoryReducer from './slices/memorySlice';
import planningReducer from './slices/planningSlice';
import notesReducer from './slices/notesSlice';
import aiReducer from './slices/aiSlice';
import settingsReducer from './slices/settingsSlice';

// RTK Query APIs
import { authApi } from './api/authApi';
import { learningApi } from './api/learningApi';

// Middleware
import { loggerMiddleware } from './middleware/logger';

const rootReducer = combineReducers({
  auth: authReducer,
  user: userReducer,
  learning: learningReducer,
  memory: memoryReducer,
  planning: planningReducer,
  notes: notesReducer,
  ai: aiReducer,
  settings: settingsReducer,
  
  // RTK Query
  [authApi.reducerPath]: authApi.reducer,
  [learningApi.reducerPath]: learningApi.reducer,
});

const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['auth', 'settings'], // 只持久化认证和设置
  blacklist: ['memory', 'learning'], // 不持久化临时数据
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
      },
    })
      .concat(authApi.middleware)
      .concat(learningApi.middleware)
      .concat(loggerMiddleware),
  devTools: __DEV__,
});

export const persistor = persistStore(store);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

### 9.2 自定义Hooks

```typescript
// src/hooks/useAppDispatch.ts
import { useDispatch } from 'react-redux';
import type { AppDispatch } from '../store/store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
```

```typescript
// src/hooks/useAppSelector.ts
import { TypedUseSelectorHook, useSelector } from 'react-redux';
import type { RootState } from '../store/store';

export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

---

## 10. 网络请求架构

### 10.1 Axios实例配置

```typescript
// src/services/api/apiClient.ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { TokenStorage } from '../storage/TokenStorage';
import { store } from '../../store/store';
import { logout } from '../../store/slices/authSlice';

class APIClient {
  private instance: AxiosInstance;

  constructor() {
    this.instance = axios.create({
      baseURL: process.env.API_BASE_URL || 'https://api.example.com',
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // 请求拦截器
    this.instance.interceptors.request.use(
      (config) => {
        // 添加认证Token
        const token = TokenStorage.getToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }

        // 添加请求ID用于追踪
        config.headers['X-Request-ID'] = this.generateRequestId();

        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );

    // 响应拦截器
    this.instance.interceptors.response.use(
      (response) => {
        return response;
      },
      async (error) => {
        const originalRequest = error.config;

        // Token过期,尝试刷新
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;

          try {
            const refreshToken = TokenStorage.getRefreshToken();
            if (refreshToken) {
              const response = await this.refreshToken(refreshToken);
              const { token, refreshToken: newRefreshToken } = response.data;

              TokenStorage.saveToken(token, newRefreshToken);
              originalRequest.headers.Authorization = `Bearer ${token}`;

              return this.instance(originalRequest);
            }
          } catch (refreshError) {
            // 刷新失败,退出登录
            TokenStorage.clearTokens();
            store.dispatch(logout());
            return Promise.reject(refreshError);
          }
        }

        // 处理网络错误
        if (!error.response) {
          error.message = '网络连接失败,请检查网络设置';
        }

        return Promise.reject(error);
      }
    );
  }

  private async refreshToken(refreshToken: string) {
    return this.instance.post('/auth/refresh', { refreshToken });
  }

  private generateRequestId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // GET请求
  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.get<T>(url, config);
    return response.data;
  }

  // POST请求
  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.post<T>(url, data, config);
    return response.data;
  }

  // PUT请求
  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.put<T>(url, data, config);
    return response.data;
  }

  // DELETE请求
  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.delete<T>(url, config);
    return response.data;
  }

  // 上传文件
  async upload<T>(url: string, file: FormData, onProgress?: (progress: number) => void): Promise<T> {
    const response = await this.instance.post<T>(url, file, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          onProgress(percentCompleted);
        }
      },
    });
    return response.data;
  }
}

export const apiClient = new APIClient();
```

---

## 11. 本地存储方案

### 11.1 MMKV存储服务

```typescript
// src/services/storage/MMKVStorage.ts
import { MMKV } from 'react-native-mmkv';

export class MMKVStorage {
  private storage: MMKV;

  constructor(id: string = 'default') {
    this.storage = new MMKV({ id });
  }

  // 字符串操作
  setString(key: string, value: string): void {
    this.storage.set(key, value);
  }

  getString(key: string): string | undefined {
    return this.storage.getString(key);
  }

  // 数字操作
  setNumber(key: string, value: number): void {
    this.storage.set(key, value);
  }

  getNumber(key: string): number | undefined {
    return this.storage.getNumber(key);
  }

  // 布尔操作
  setBoolean(key: string, value: boolean): void {
    this.storage.set(key, value);
  }

  getBoolean(key: string): boolean | undefined {
    return this.storage.getBoolean(key);
  }

  // 对象操作(JSON)
  setObject<T>(key: string, value: T): void {
    this.storage.set(key, JSON.stringify(value));
  }

  getObject<T>(key: string): T | undefined {
    const value = this.storage.getString(key);
    if (!value) return undefined;
    
    try {
      return JSON.parse(value) as T;
    } catch (error) {
      console.error('Failed to parse JSON:', error);
      return undefined;
    }
  }

  // 删除
  delete(key: string): void {
    this.storage.delete(key);
  }

  // 清除所有
  clearAll(): void {
    this.storage.clearAll();
  }

  // 获取所有键
  getAllKeys(): string[] {
    return this.storage.getAllKeys();
  }

  // 检查键是否存在
  contains(key: string): boolean {
    return this.storage.contains(key);
  }
}

// 导出单例
export const storage = new MMKVStorage();
export const secureStorage = new MMKVStorage('secure'); // 用于敏感数据
```

---

## 12. AI集成方案

### 12.1 AI服务抽象层

```typescript
// src/services/ai/AIService.ts
export interface AIServiceInterface {
  chat(request: ChatRequest): Promise<string>;
  chatStream(request: ChatRequest, onChunk: (chunk: string) => void): Promise<void>;
  generatePlan(request: PlanGenerationRequest): Promise<LearningPlan>;
  correctEssay(essay: string): Promise<EssayCorrection>;
  evaluatePronunciation(audioData: string): Promise<PronunciationScore>;
}

// 抽象基类
export abstract class BaseAIService implements AIServiceInterface {
  abstract chat(request: ChatRequest): Promise<string>;
  abstract chatStream(request: ChatRequest, onChunk: (chunk: string) => void): Promise<void>;
  
  async generatePlan(request: PlanGenerationRequest): Promise<LearningPlan> {
    // 默认实现
    throw new Error('Not implemented');
  }

  async correctEssay(essay: string): Promise<EssayCorrection> {
    throw new Error('Not implemented');
  }

  async evaluatePronunciation(audioData: string): Promise<PronunciationScore> {
    throw new Error('Not implemented');
  }
}
```

### 12.2 AI服务工厂

```typescript
// src/services/ai/AIServiceFactory.ts
import { OpenAIAdapter } from './OpenAIAdapter';
import { BaseAIService } from './AIService';

export enum AIProvider {
  OpenAI = 'openai',
  Claude = 'claude',
  LocalModel = 'local',
}

export class AIServiceFactory {
  static create(provider: AIProvider = AIProvider.OpenAI): BaseAIService {
    switch (provider) {
      case AIProvider.OpenAI:
        return new OpenAIAdapter();
      
      case AIProvider.Claude:
        // return new ClaudeAdapter(); // 未来实现
        throw new Error('Claude adapter not implemented yet');
      
      case AIProvider.LocalModel:
        // return new LocalModelAdapter(); // 未来实现
        throw new Error('Local model adapter not implemented yet');
      
      default:
        return new OpenAIAdapter();
    }
  }
}

// 使用示例
const aiService = AIServiceFactory.create(AIProvider.OpenAI);
```

---

## 13. 性能优化策略

### 13.1 列表性能优化

```typescript
// src/components/common/OptimizedFlatList/index.tsx
import React, { useCallback, useMemo } from 'react';
import { FlatList, FlatListProps, View } from 'react-native';

interface OptimizedFlatListProps<T> extends Omit<FlatListProps<T>, 'renderItem'> {
  data: T[];
  renderItem: (item: T, index: number) => React.ReactElement;
  keyExtractor: (item: T, index: number) => string;
  itemHeight?: number;
}

export function OptimizedFlatList<T>({
  data,
  renderItem,
  keyExtractor,
  itemHeight,
  ...props
}: OptimizedFlatListProps<T>) {
  
  // 使用useCallback优化渲染函数
  const renderItemCallback = useCallback(
    ({ item, index }: { item: T; index: number }) => renderItem(item, index),
    [renderItem]
  );

  // 使用useMemo缓存数据
  const memoizedData = useMemo(() => data, [data]);

  return (
    <FlatList
      data={memoizedData}
      renderItem={renderItemCallback}
      keyExtractor={keyExtractor}
      // 性能优化配置
      removeClippedSubviews={true}
      maxToRenderPerBatch={10}
      updateCellsBatchingPeriod={50}
      initialNumToRender={10}
      windowSize={10}
      getItemLayout={
        itemHeight
          ? (data, index) => ({
              length: itemHeight,
              offset: itemHeight * index,
              index,
            })
          : undefined
      }
      {...props}
    />
  );
}
```

### 13.2 图片加载优化

```typescript
// src/components/common/OptimizedImage/index.tsx
import React, { useState } from 'react';
import { Image, ImageProps, StyleSheet, View, ActivityIndicator } from 'react-native';
import FastImage from 'react-native-fast-image';

interface OptimizedImageProps extends Omit<ImageProps, 'source'> {
  source: { uri: string } | number;
  useFastImage?: boolean;
  placeholder?: React.ReactNode;
  errorComponent?: React.ReactNode;
}

export const OptimizedImage: React.FC<OptimizedImageProps> = ({
  source,
  style,
  useFastImage = true,
  placeholder,
  errorComponent,
  ...props
}) => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(false);

  if (typeof source === 'number') {
    // 本地图片
    return <Image source={source} style={style} {...props} />;
  }

  if (error && errorComponent) {
    return <>{errorComponent}</>;
  }

  if (useFastImage) {
    return (
      <View style={style}>
        {loading && (placeholder || <ActivityIndicator />)}
        <FastImage
          source={{ uri: source.uri, priority: FastImage.priority.normal }}
          style={[StyleSheet.absoluteFill, style]}
          onLoadStart={() => setLoading(true)}
          onLoadEnd={() => setLoading(false)}
          onError={() => {
            setLoading(false);
            setError(true);
          }}
          resizeMode={FastImage.resizeMode.cover}
        />
      </View>
    );
  }

  return (
    <Image
      source={source}
      style={style}
      onLoadStart={() => setLoading(true)}
      onLoadEnd={() => setLoading(false)}
      onError={() => {
        setLoading(false);
        setError(true);
      }}
      {...props}
    />
  );
};
```

### 13.3 防抖与节流

```typescript
// src/hooks/useDebounce.ts
import { useEffect, useState } from 'react';

export function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

```typescript
// src/hooks/useThrottle.ts
import { useRef, useCallback } from 'react';

export function useThrottle<T extends (...args: any[]) => any>(
  callback: T,
  delay: number = 500
): (...args: Parameters<T>) => void {
  const lastRun = useRef(Date.now());

  return useCallback(
    (...args: Parameters<T>) => {
      const now = Date.now();
      if (now - lastRun.current >= delay) {
        callback(...args);
        lastRun.current = now;
      }
    },
    [callback, delay]
  );
}
```

---

## 14. 安全方案

### 14.1 敏感数据加密

```typescript
// src/utils/security/encryption.ts
import CryptoJS from 'crypto-js';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'default-key-change-in-production';

export class EncryptionService {
  /**
   * 加密数据
   */
  static encrypt(data: string): string {
    return CryptoJS.AES.encrypt(data, ENCRYPTION_KEY).toString();
  }

  /**
   * 解密数据
   */
  static decrypt(encryptedData: string): string {
    const bytes = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
    return bytes.toString(CryptoJS.enc.Utf8);
  }

  /**
   * Hash密码
   */
  static hashPassword(password: string): string {
    return CryptoJS.SHA256(password).toString();
  }

  /**
   * 生成随机Token
   */
  static generateToken(length: number = 32): string {
    return CryptoJS.lib.WordArray.random(length).toString();
  }
}
```

### 14.2 代码混淆配置

```javascript
// android/app/proguard-rules.pro
-keepattributes *Annotation*
-keepattributes SourceFile,LineNumberTable
-keep public class * extends java.lang.Exception

# React Native
-keep class com.facebook.react.** { *; }
-keep class com.facebook.hermes.** { *; }

# SQLite
-keep class net.sqlcipher.** { *; }

# 自定义规则
-keep class com.yourapp.modules.** { *; }
```

---

## 15. 开发环境配置

### 15.1 环境变量管理

```bash
# .env.development
API_BASE_URL=https://dev-api.example.com
OPENAI_API_KEY=sk-dev-xxx
ENCRYPTION_KEY=dev-encryption-key
SENTRY_DSN=https://xxx@sentry.io/xxx
DEBUG_MODE=true
```

```bash
# .env.production
API_BASE_URL=https://api.example.com
OPENAI_API_KEY=sk-prod-xxx
ENCRYPTION_KEY=prod-encryption-key-change-me
SENTRY_DSN=https://xxx@sentry.io/xxx
DEBUG_MODE=false
```

```typescript
// src/config/env.ts
import Config from 'react-native-config';

export const ENV = {
  API_BASE_URL: Config.API_BASE_URL || '',
  OPENAI_API_KEY: Config.OPENAI_API_KEY || '',
  ENCRYPTION_KEY: Config.ENCRYPTION_KEY || '',
  SENTRY_DSN: Config.SENTRY_DSN || '',
  DEBUG_MODE: Config.DEBUG_MODE === 'true',
};
```

### 15.2 必要工具安装

```bash
# 全局工具
npm install -g react-native-cli
npm install -g @react-native-community/cli

# iOS依赖
cd ios && pod install

# Android依赖确认
# 确保Android SDK, JDK配置正确
```

---

## 16. 项目初始化步骤

### 16.1 创建项目

```bash
# 1. 创建React Native项目
npx react-native init AILearningAssistant --template react-native-template-typescript

cd AILearningAssistant

# 2. 安装核心依赖
npm install @reduxjs/toolkit react-redux redux-persist
npm install @react-navigation/native @react-navigation/stack @react-navigation/bottom-tabs
npm install react-native-screens react-native-safe-area-context
npm install react-native-gesture-handler react-native-reanimated

# 3. 安装UI库
npm install react-native-paper react-native-vector-icons
npm install react-native-svg react-native-linear-gradient
npm install victory-native

# 4. 安装存储库
npm install react-native-mmkv
npm install react-native-sqlite-storage
npm install @react-native-async-storage/async-storage

# 5. 安装网络请求
npm install axios

# 6. 安装音频库
npm install react-native-sound
npm install @react-native-community/voice

# 7. 安装工具库
npm install date-fns lodash
npm install react-hook-form yup

# 8. 安装开发工具
npm install -D @types/react @types/react-native
npm install -D @typescript-eslint/parser @typescript-eslint/eslint-plugin
npm install -D prettier eslint-plugin-prettier
npm install -D @react-native-community/eslint-config

# 9. 安装环境变量
npm install react-native-config
npm install react-native-dotenv

# 10. 安装图片优化
npm install react-native-fast-image
```

### 16.2 iOS配置

```bash
cd ios
pod install
cd ..

# 配置Info.plist(添加权限)
# - 麦克风权限(口语练习)
# - 相机权限(可选,未来扫描功能)
```

### 16.3 Android配置

```gradle
// android/app/build.gradle

android {
    compileSdkVersion 33
    
    defaultConfig {
        minSdkVersion 23
        targetSdkVersion 33
        multiDexEnabled true
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}
```

```xml
<!-- android/app/src/main/AndroidManifest.xml -->
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.RECORD_AUDIO" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
```

### 16.4 项目初始化代码

```typescript
// src/App.tsx
import React, { useEffect } from 'react';
import { StatusBar } from 'react-native';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { SafeAreaProvider } from 'react-native-safe-area-context';

import { store, persistor } from './store/store';
import { RootNavigator } from './navigation/RootNavigator';
import { ThemeProvider } from './contexts/ThemeContext';

const App: React.FC = () => {
  useEffect(() => {
    // 初始化数据库
    // 初始化同步服务
  }, []);

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <Provider store={store}>
        <PersistGate loading={null} persistor={persistor}>
          <SafeAreaProvider>
            <ThemeProvider>
              <StatusBar barStyle="dark-content" />
              <RootNavigator />
            </ThemeProvider>
          </SafeAreaProvider>
        </PersistGate>
      </Provider>
    </GestureHandlerRootView>
  );
};

export default App;
```

---

## 17. 开发规范

### 17.1 代码规范

#### TypeScript规范

```typescript
// ✅ 正确示例
interface User {
  id: string;
  username: string;
  email: string;
  createdAt: Date;
}

// 使用类型安全的函数
function getUser(id: string): Promise<User> {
  return apiClient.get<User>(`/users/${id}`);
}

// ❌ 错误示例
function getUser(id: any): any {
  return apiClient.get(`/users/${id}`);
}
```

#### 命名规范

```typescript
// 组件: PascalCase
export const UserProfile: React.FC = () => {};

// 函数/变量: camelCase
const handleSubmit = () => {};
const userId = '123';

// 常量: UPPER_SNAKE_CASE
const API_BASE_URL = 'https://api.example.com';
const MAX_RETRY_COUNT = 3;

// 接口/类型: PascalCase
interface UserData {}
type ApiResponse<T> = {};

// 文件名:
// - 组件: PascalCase (UserProfile.tsx)
// - 工具/服务: camelCase (apiClient.ts)
// - 类型定义: camelCase.types.ts (user.types.ts)
```

### 17.2 ESLint配置

```javascript
// .eslintrc.js
module.exports = {
  root: true,
  extends: [
    '@react-native-community',
    'plugin:@typescript-eslint/recommended',
    'prettier',
  ],
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  rules: {
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    '@typescript-eslint/no-unused-vars': 'warn',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    'react-hooks/exhaustive-deps': 'warn',
  },
};
```

### 17.3 Prettier配置

```javascript
// .prettierrc.js
module.exports = {
  semi: true,
  singleQuote: true,
  trailingComma: 'es5',
  printWidth: 100,
  tabWidth: 2,
  arrowParens: 'always',
};
```

### 17.4 Git提交规范

```bash
# 提交格式
<type>(<scope>): <subject>

# Type类型:
feat:     新功能
fix:      修复Bug
docs:     文档更新
style:    代码格式(不影响代码运行)
refactor: 重构
test:     测试相关
chore:    构建/工具链

# 示例:
feat(auth): 添加微信登录功能
fix(memory): 修复SM-2算法计算错误
docs(readme): 更新安装说明
refactor(api): 优化网络请求错误处理
```

---

## 18. 测试策略

### 18.1 单元测试

```typescript
// __tests__/utils/algorithms/sm2.test.ts
import { SM2Algorithm } from '../../../src/utils/algorithms/sm2';

describe('SM2Algorithm', () => {
  describe('calculateNextReview', () => {
    it('should set interval to 1 day for first review with quality >= 3', () => {
      const card = {
        id: '1',
        easeFactor: 2.5,
        interval: 0,
        repetitions: 0,
        nextReviewDate: new Date(),
      };

      const result = SM2Algorithm.calculateNextReview(card, 4);

      expect(result.interval).toBe(1);
      expect(result.repetitions).toBe(1);
    });

    it('should reset repetitions when quality < 3', () => {
      const card = {
        id: '1',
        easeFactor: 2.5,
        interval: 10,
        repetitions: 5,
        nextReviewDate: new Date(),
      };

      const result = SM2Algorithm.calculateNextReview(card, 2);

      expect(result.interval).toBe(1);
      expect(result.repetitions).toBe(0);
    });
  });

  describe('getTodayReviewCards', () => {
    it('should return cards due today', () => {
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);

      const cards = [
        { id: '1', nextReviewDate: yesterday } as ReviewCard,
        { id: '2', nextReviewDate: today } as ReviewCard,
        { id: '3', nextReviewDate: tomorrow } as ReviewCard,
      ];

      const result = SM2Algorithm.getTodayReviewCards(cards);

      expect(result).toHaveLength(2);
      expect(result.map(c => c.id)).toEqual(['1', '2']);
    });
  });
});
```

### 18.2 组件测试

```typescript
// __tests__/components/common/Button.test.tsx
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import { Button } from '../../../src/components/common/Button';

describe('Button Component', () => {
  it('renders correctly with title', () => {
    const { getByText } = render(<Button title="Click Me" onPress={() => {}} />);
    expect(getByText('Click Me')).toBeTruthy();
  });

  it('calls onPress when pressed', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(<Button title="Click Me" onPress={onPressMock} />);
    
    fireEvent.press(getByText('Click Me'));
    expect(onPressMock).toHaveBeenCalledTimes(1);
  });

  it('shows loading indicator when loading is true', () => {
    const { getByTestId } = render(
      <Button title="Click Me" onPress={() => {}} loading={true} />
    );
    
    expect(getByTestId('loading-indicator')).toBeTruthy();
  });

  it('is disabled when disabled prop is true', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <Button title="Click Me" onPress={onPressMock} disabled={true} />
    );
    
    fireEvent.press(getByText('Click Me'));
    expect(onPressMock).not.toHaveBeenCalled();
  });
});
```

### 18.3 测试配置

```javascript
// jest.config.js
module.exports = {
  preset: 'react-native',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  transformIgnorePatterns: [
    'node_modules/(?!(react-native|@react-native|react-native-vector-icons)/)',
  ],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.types.ts',
    '!src/**/index.ts',
  ],
  coverageThreshold: {
    global: {
      statements: 70,
      branches: 70,
      functions: 70,
      lines: 70,
    },
  },
};
```

---

## 19. CI/CD流程

### 19.1 GitHub Actions配置

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linter
      run: npm run lint
    
    - name: Run tests
      run: npm test -- --coverage
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3

  build-ios:
    runs-on: macos-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Install pods
      run: cd ios && pod install
    
    - name: Build iOS
      run: npx react-native run-ios --configuration Release

  build-android:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Setup Java
      uses: actions/setup-java@v3
      with:
        distribution: 'zulu'
        java-version: '11'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build Android
      run: cd android && ./gradlew assembleRelease
```

### 19.2 发布流程

```bash
# iOS发布
# 1. 更新版本号
cd ios
fastlane bump_version

# 2. 构建并上传TestFlight
fastlane beta

# Android发布
# 1. 更新版本号
# android/app/build.gradle中修改versionCode和versionName

# 2. 构建Release APK
cd android
./gradlew assembleRelease

# 3. 构建Release AAB (Google Play)
./gradlew bundleRelease
```

---

## 20. 迭代开发计划

### 20.1 第一阶段 (Week 1-4): MVP核心功能

#### Week 1: 项目搭建与基础架构
- [x] 项目初始化
- [x] 目录结构搭建
- [x] 核心依赖安装
- [x] 导航系统配置
- [x] Redux Store配置
- [x] 主题系统实现

#### Week 2: 认证与用户系统
- [ ] 登录/注册UI
- [ ] JWT Token管理
- [ ] 用户信息存储
- [ ] 第三方登录集成(微信)

#### Week 3: 记忆强化模块
- [ ] SQLite数据库配置
- [ ] SM-2算法实现
- [ ] 复习队列管理
- [ ] 卡片CRUD操作
- [ ] 复习界面实现

#### Week 4: 学习内容模块
- [ ] 词汇学习界面
- [ ] 单词播放功能
- [ ] 词汇数据导入
- [ ] 学习记录保存

### 20.2 第二阶段 (Week 5-8): 扩展功能

#### Week 5-6: AI集成
- [ ] OpenAI API集成
- [ ] AI对话界面
- [ ] 流式响应处理
- [ ] AI缓存机制

#### Week 7: 学习规划
- [ ] 目标管理
- [ ] AI计划生成
- [ ] 任务调度
- [ ] 进度追踪

#### Week 8: 笔记系统
- [ ] Markdown编辑器
- [ ] 笔记列表
- [ ] 笔记搜索
- [ ] 标签管理

### 20.3 第三阶段 (Week 9-12): 优化与发布

#### Week 9-10: 数据统计与可视化
- [ ] 学习数据统计
- [ ] 图表展示
- [ ] 学习报告生成
- [ ] 成就系统

#### Week 11: 性能优化与测试
- [ ] 性能分析与优化
- [ ] 单元测试补充
- [ ] 集成测试
- [ ] Bug修复

#### Week 12: 发布准备
- [ ] 应用图标与启动页
- [ ] 隐私政策
- [ ] 用户协议
- [ ] App Store/Google Play提交

---

## 21. 总结与建议

### 21.1 架构优势

1. **模块化设计**: 清晰的模块划分,便于团队协作和后期维护
2. **离线优先**: SQLite + 同步机制保证离线可用性
3. **可扩展性**: 抽象层设计,易于添加新功能和切换服务
4. **类型安全**: TypeScript全面覆盖,减少运行时错误
5. **性能优化**: 多层次的性能优化策略

### 21.2 风险点与应对

#### 风险1: 复杂度控制
- **应对**: 分阶段开发,先MVP后扩展
- **建议**: 每个Sprint聚焦核心功能,避免过早优化

#### 风险2: 数据同步复杂性
- **应对**: 使用成熟的同步队列方案
- **建议**: 充分测试网络异常场景

#### 风险3: AI成本控制
- **应对**: 缓存机制 + 使用限制
- **建议**: 监控API调用量,及时优化

### 21.3 后续优化方向

1. **性能监控**: 集成Sentry或Firebase Performance
2. **A/B测试**: 实验不同UI方案
3. **推送通知**: 学习提醒功能
4. **社交功能**: 学习小组、排行榜
5. **国际化**: 多语言支持

### 21.4 开发建议

1. **优先级**: 先实现核心学习流程,再添加辅助功能
2. **迭代**: 小步快跑,频繁发布测试版收集反馈
3. **测试**: 重视单元测试,保证核心算法正确性
4. **文档**: 及时更新技术文档和API文档
5. **代码审查**: 保持代码质量,定期Code Review

---

## 附录

### A. 常用命令

```bash
# 开发
npm run android      # 运行Android
npm run ios          # 运行iOS
npm start            # 启动Metro

# 测试
npm test            # 运行测试
npm run test:watch  # 监听模式测试
npm run test:coverage # 测试覆盖率

# 代码检查
npm run lint        # ESLint检查
npm run format      # Prettier格式化

# 构建
npm run build:android  # Android Release构建
npm run build:ios      # iOS Release构建
```

### B. 问题排查

```bash
# 清除缓存
npm start -- --reset-cache

# 清除Android构建
cd android && ./gradlew clean

# 清除iOS构建
cd ios && pod deintegrate && pod install

# 清除node_modules
rm -rf node_modules && npm install
```

### C. 参考资源

- [React Native官方文档](https://reactnative.dev/)
- [Redux Toolkit文档](https://redux-toolkit.js.org/)
- [React Navigation文档](https://reactnavigation.org/)
- [TypeScript文档](https://www.typescriptlang.org/)
- [SM-2算法论文](https://www.supermemo.com/en/archives1990-2015/english/ol/sm2)

---

**文档结束**

本文档涵盖了AI学习助手React Native项目的完整架构设计和实施方案,为项目开发提供了详细的技术指导。建议开发团队严格按照本文档进行实施,并在实践中不断优化和完善。